:imagesdir: IMG2
= Отчет по лабораторной работе №2

== Маслов А.В. КЭ-413

== Задание 1

* Открыть спецификацию на микроконтроллер STM32F411

узнать на каком адресе расположен модуль GPIOC:

image::1.png[]

Узнать смещение регистра GPIOС_MODER относительно адреса GPIOC:
 Address offset: 0x00
 
Узнать смещение регистра GPIOC_ODR относительно адреса GPIOC: 0x14

* Записать по адресу регистра GPIOC_MODER биты 10,16,18 в 1, а биты 11,17,19 в 0.


Для начала надо сделать указатель из адреса 

  uint32_t -- тип регистра
  Pointer -- указатель
  reinterpret_cast - преобразовать в указатель.
  volatile -- при компиляции данные действия не удалялись микроконтроллером автоматически когда не используются 
 Далее раыменовываем указатель и записываем туда что надо

  *ModerPointer |= ((1 << 10 )|(1<<16)|(1<<18));   //Запишем по адресу GPIOC_MODER биты 10,16,18 в 1
  *ModerPointer &= ~ ((1 << 11 )|(1<<17)|(1<<19)); // //Запишем по адресу  GPIOC_MODER биты 19,17,11 в 0


image::2.png[]

* Записать по адресу регистра GPIOC_ODR биты 5,8,9 в 1

  *OdrPointer |= ((1 << 5 )|(1<<8)|(1<<9)); //Запишем по адресу GPIOC_ODR биты 5,8,9 в 1

* Написать функцию задержки используя цикл void Delay().

Напишем функцию задержки void Delay() до main()

image::3.png[]
 
Вызовем ее после установки битов
 
  delay (1'000'000);
  
* После задержки запишем по адресу регистра GPIOC_ODR биты 5,8,9 в 0

 *OdrPointer &= ~ ((1 << 5 )|(1<<8)|(1<<9)); //Запишем по адресу регистра GPIOC_ODR биты 5,8,9 в 0

* Запустить программу, в пошаговой отладке в окне Register, посмотреть, что происходит с регистрами GPIOС_MODER и GPIOС_ODR.

*Изменения в регистре MODER:*

до запуска программы:

image::4.png[]

до задержки программы:

image::7.png[]

в конце программы:

image::10.png[]



*Изменения в регистре ODR:*
до запуска программы:

image::5.png[]

до задержки программы:

image::8.png[]

в конце программы:

image::11.png[]

*Изменения в MEMORY:*

до запуска программы:

image::6.png[]

до задержки программы:

image::9.png[]


в конце программы:

image::12.png[]

== Задание 2

* Создать указатель типа volatile int*, которая будет содержать адрес регистра GPIOC_MODER

   volatile uint32_t *ModerPointer = reinterpret_cast<volatile uint32_t*>(ModerAddr) ;


* Создать переменную типа int и записать туда значение, которое содержится по этому адресу

  uint32_t Moder = *ModerPointer;
  
Запустить отладку, запустить окно Memory и проверить, что по этому адресу лежит это значение

В отладке открыть окно регистры и проверить, что значение регистра GPIOC_MODER, совпадает со значением в переменной типа int

Проделать тоже самое с произвольным адресом в ОЗУ.
Открыв окно Watch набрать нужное в поиске.

image::13.png[]



== Задание 3

* Ознакомиться с техническим описанием регистров тактирования микропроцессора

Существуют несколько источников частоты  :​

HSI (high-speed internal) — внутренний высокочастотный RC-генератор.​

HSE (high-speed external) — внешний высокочастотный генератор.​

PLL — система ФАПЧ. Исходный сигнал он получает от HSI или HSE, а на выходе у него уже другая частота.


* Произвести настройку тактирования микропроцессора по варианту (2 вариант)


[width="100%",options="header,footer"]
|====================
|  Номер варианта | Источник тактирования |  Частота тактирования
|  1| HSE |  1 Мгц
|====================


Подключим источник внешнего тактирования:

 RCC::CR::HSEON::Enable::Set();

Необходимо дождаться стабилизации ичточника через HSEReady:

 while (!RCC::CR::HSERDY::Enable::IsSet());
 
Теперь обозначим частоту источника как системную:

 RCC::CFGR::SW::Hse::Set();

И дождемся переключения:

 while (!RCC::CFGR::SWS::Hse::IsSet());

Перед тем, как уменьшать частоту с помощью делителя, недобходимо посмотреть в даташите. 

image::14.png[]

В случае с частотой 1,2 Мгц делить не нужно, а выше - нужно.

В ходе компиляции возникли ошибки, так как не поменял регистр HSE.

image::15.png[]


== Задание 4

* Сделать программу, которая при нажатии кнопки UserButton на отладочной плате

[source,]
----
bool flag = false;
for (; ;)
{

if(GPIOC::IDR::IDR13::Low::IsSet()) //kn vkl
{
while(GPIOC::IDR::IDR13::Low::IsSet())
{
} ;

if(flag)
{
GPIOA::ODR::ODR5::High::Set ();
GPIOC::ODR::ODR5::High::Set ();
GPIOC::ODR::ODR8::High::Set ();
GPIOC::ODR::ODR9::High::Set ();
flag = false ;
}
else
{
GPIOA::ODR::ODR5::Low::Set ();
GPIOC::ODR::ODR5::Low::Set ();
GPIOC::ODR::ODR8::Low::Set ();
GPIOC::ODR::ODR9::Low::Set ();
flag = true ;
}
}
}
return 0;
----
До этого включаем регистры диодов, настраиваем их на выход, настраиваем частоту (внешнюю)
Создав переменную типа bool и присвоив ей некое значение, запускаем цикл, который проверяет состояние кнопки (IDR13). Пока она не нажата, идет бесконечный цикл, но при нажатии светодиоды зажигаются, а перемнной flag присваивается значение false, нас в бесконечный цикл. При следующем нажатии включенные диоды выключаются, переменной присваивается значение true. При следующем нажатия диоды включатся, и так далее.




