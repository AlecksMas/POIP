:imagesdir: IMG3
= Отчет по лабораторной работе №3

== Маслов А.В. КЭ-413

== Задание

*  Светодиоды должны гореть раз в 500 мс​. Сделать задержку на 500, 1000, 1500 мс, вместо цикла for(..) c с помощью таймера​ 1. Как то непонятно, что надо было сделать? Как это сделали? просто код и все.. я код не понимаю, мне словами надо написать.

Ну для начала создали новый проект. Создали структуру проекта в соотвествии со структурой папок. Подключили библиотеки регистров. Использоваться будет 32-битный таймер общего назначения TIM2, который будет генерировать событие "переполнение".

Для таймера нужно подключить библиотеку регистров: 

 #include "tim2registers.hpp" //for tim2

Таймер необходимо подключить к источнику тактирования. он тактируется от шины APB1, через модуль RCC

 RCC::APB1ENR::TIM2EN::Enable::Set();

Настроим его на генерацию переполнения. Реализуется через функцию delay

 TIM2::CR1::URS::OverFlow::Set();

ARR - регистр автоперезагрузки, В этот регистр записывается число, до которого будет идти счет. При достижении этого значения, содержимое счетчика CNT обнуляется и формируются прерывание или запрос DMA (если они разрешены).​

Для того чтобы задавать значение задержки в милисекундах, домножим переменную на 16 тысяч.

----
void delay(std::uint32_t delay)        //Delay - функция задержки, прописывается в миллисекундах. Функция delay() приостанавливает исполнение программы на величину времени time, заданного в миллисекундах. 
{
  TIM2::ARR::Write(16'000 *delay); // число до которого будет считать. Указанна переменная, которой будет задаваться длительность задержки, так как используемая частота тактирования 16МГц
  TIM2::SR::UIF::NoUpdate::Set();
  TIM2::CNT::Write(0); обнуление счетчика
  TIM2::CR1::CEN::Enable::Set();  // CEN отвечает за включение счетчика в регистре CR1
  while(TIM2::SR::UIF::NoUpdate::IsSet()) Скинуть флаг генерации прерывания UIF по событию в регистре статуса SR.​
   {
   }                       
};
----
    
Настройка частоты.

Подключаем источник внутренней частоты   
  
 RCC::CR::HSION::On::Set (); 

Дожидаемся стабилизации через Ready

 while ( ! RCC::CR::HSIRDY::Enable::IsSet () ) // дожидаемся стабилизации через Ready:
    {
    };   

Назначим источник как системную частоту

 RCC::CFGR::SW::Hsi::Set(); 
 
Ожидание переключения на системную

    while ( ! RCC::CFGR::SWS::Hsi::IsSet () ) //ожидание переключение на системную
    {
    };

Настройка портов

    RCC::AHB1ENR::GPIOAEN::Enable::Set();// настройка портов на выходы
    GPIOA::MODER::MODER5::Output::Set();
    
    RCC::AHB1ENR::GPIOCEN::Enable::Set();  //настройка портов на выходы
    GPIOC::MODER::MODER5::Output::Set();
    GPIOC::MODER::MODER8::Output::Set();
    GPIOC::MODER::MODER9::Output::Set();
    GPIOC::MODER::MODER13::Input::Set();


Реализуем кнопку чтобы нужно было только нажимать.


[source,]
----
 struct Button    
 {
   static bool IsPressed()  //задаемнажатие кнопки
   {
     bool result = false;
     if (GPIOC::IDR::IDR13::Low::IsSet() )
     {
       while (GPIOC::IDR::IDR13::Low::IsSet() )
       {
         result = true;
       };
     }
     return result;
   }
 };
----

Реализация переключения диода с помощью функции Toggle

----
template <typename Port, std::uint32_t pinNum>
struct Led                          
{
  static void Toggle()
  {
    Port::ODR::Toggle(1<<pinNum);
  }
};

----

Через using сокращаем обращение к диодам

----
 using Led1 = Led<GPIOC,5>;  //Светодиод Led1 подключен к выводу 9 порта GPIOC
 using Led2 = Led<GPIOC,8>;
 using Led3 = Led<GPIOC,9>;
 using Led4 = Led<GPIOA,5>;
----

Ну и основная программа

----
int main()
{
  for (; ;)
  {
      Led1::Toggle ();
      Led2::Toggle ();
      Led3::Toggle ();
      Led4::Toggle ();
      delay(500); //горят пол секунды 4 диода  
      Led1::Toggle ();
      Led2::Toggle ();
      Led3::Toggle ();
      Led4::Toggle ();
      delay (1000) ;//горят 1с 4 диода  
      Led1::Toggle ();
      Led2::Toggle ();
      Led3::Toggle ();
      Led4::Toggle ();
      delay (1500);//горят 1.5с 4 диода
  } 
  return 0;
}   
    
----   
    
  