:imagesdir: IMG3
= Отчет по лабораторной работе №3

== Маслов А.В. КЭ-413

== Задание

*  Светодиоды должны гореть раз в 500 мс​. Сделать задержку на 500, 1000, 1500 мс, вместо цикла for(..) c с помощью таймера​


[source,]
----
#include "rccregisters.hpp" //for RTC
#include "gpioaregisters.hpp" //for gpioa
#include "gpiocregisters.hpp" //for gpioc
#include "tim2registers.hpp" //for tim2

extern "C"

{
  int __low_level_init(void)
  {
    RCC::CR::HSION::On::Set (); // подключаем источник внутренней частоты 
    while ( ! RCC::CR::HSIRDY::Enable::IsSet () ) // дожидаемся стабилизации через Ready:
    {
    };
    
      RCC::CFGR::SW::Hsi::Set();  // Назначаем источнику  системную частоту
      while ( ! RCC::CFGR::SWS::Hsi::IsSet () ) //ожидание переключение на системную
    {
    };
    RCC::AHB1ENR::GPIOAEN::Enable::Set();// настройка портов на выходы
    GPIOA::MODER::MODER5::Output::Set();
    
    RCC::AHB1ENR::GPIOCEN::Enable::Set();  //настройка портов на выходы, а один как вход.
    GPIOC::MODER::MODER5::Output::Set();
    GPIOC::MODER::MODER8::Output::Set();
    GPIOC::MODER::MODER9::Output::Set();
    GPIOC::MODER::MODER13::Input::Set();
    
    RCC::APB1ENR::TIM2EN::Enable::Set(); //подключим таймер к источнику тактирования
    TIM2::CR1::URS::OverFlow::Set(); //генерация переполнения, чтобы произошел запрос на прерывание, который реализуется через функцию delay 
    return 0;
  }
}

void delay(std::uint32_t delay)        //Delay - функция задержки, прописывается в миллисекундах. Функция delay() приостанавливает исполнение программы на величину времени time, заданного в миллисекундах.
{
  TIM2::ARR::Write(16'000 *delay); // число до которого будет считать. Указанна переменная, которой будет задаваться длительность задержки, так как используемая частота тактирования 16МГц
  TIM2::SR::UIF::NoUpdate::Set();
  TIM2::CNT::Write(0); оббнуление счетчика
  TIM2::CR1::CEN::Enable::Set();  // включение счетчика
  while(TIM2::SR::UIF::NoUpdate::IsSet())  //сброс флага прерывания
   {
   }                       
};

 struct Button    
 {
   static bool IsPressed()  //нажатие кнопки
   {
     bool result = false;
     if (GPIOC::IDR::IDR13::Low::IsSet() )
     {
       while (GPIOC::IDR::IDR13::Low::IsSet() )
       {
         result = true;
       };
     }
     return result;
   }
 };

template <typename Port, std::uint32_t pinNum>
struct Led                          // 
{
  static void Toggle()
  {
    Port::ODR::Toggle(1<<pinNum);
  }
};

using Led1 = Led<GPIOC,5>;  //Светодиод Led1 подключен к выводу 9 порта GPIOC
using Led2 = Led<GPIOC,8>;
using Led3 = Led<GPIOC,9>;
using Led4 = Led<GPIOA,5>;


int main()
{
  for (; ;)
  {
      Led1::Toggle ();
      Led2::Toggle ();
      Led3::Toggle ();
      Led4::Toggle ();
      delay(500); //горят пол секунды 4 диода  
      Led1::Toggle ();
      Led2::Toggle ();
      Led3::Toggle ();
      Led4::Toggle ();
      delay (1000) ;//горят 1 с 4 диода  
      Led1::Toggle ();
      Led2::Toggle ();
      Led3::Toggle ();
      Led4::Toggle ();
      delay (1500);//горят 1.5 с 4 диода
  } 
  return 0;
}
----















