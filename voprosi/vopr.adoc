:imagesdir: IM1
= Ответы на контрольные вопросы. 

*Выполнил: Маслов А.В., КЭ-413*



=== 1.Что такое POD типы данных?
Простая структура данных (англ. plain old data, POD) — в современных языках программирования высокого уровня тип данных, имеющий жёстко определённое расположение полей в памяти, не требующий ограничения доступа и автоматического управления. Переменные такого типа можно копировать простыми процедурами копирования участков памяти наподобие memcpy. Противоположность — управляемая структура данных.

Проще всего простую структуру данных определить от противного. Если компилятор скрытно от пользователя переставил поля местами, или при создании структуры данных скрытно вызывает конструктор, или при уничтожении структуры вызывает деструктор, или при копировании — особую процедуру копирования, то это управляемая (то есть не простая) структура.

=== 2.Назовите все типы данных в языке С++

image::1.png[]

К основным типам данных относят:

* *int (целый тип):*

Эти типы данных представляют значения из множества целых чисел.

Например:
 [source,]
----
5
-99
444
----

 
* **float (вещественные числа с плавающей точкой)**:

Типы данных с плавающей запятой разрешают представлять значения из множества вещественных чисел. 

Например:
 [source,]
----
8.33
7.88
-99.99
----

* double (вещественные числа с плавающей точкой двойной точности); 
* char (символьный тип);

* **bool (логический)**:

Переменные типа bool могут принимать только два значения:
[source,]
----
true – истина,

false – ложь.
----

Эти переменные используются для проверки логических выражений. Числовое значение true равно 1. Числовое значение false равно 0.

Для формирования других типов данных используют основные типы + так называемые спецификаторы. Типы данных, созданные на базе стандартных типов с использованием спецификаторов, называют составными типами данных. В C++ определены четыре спецификатора типов данных:

* short - короткий; 
* long - длинный; 
* signed-знаковый; 
* unsigned-беззнаковый.




=== 3.Что такое пользовательский тип? 

Вы можете определить свой тип сами, либо сделать псевдоним типа. Любой
класс или структура, определенная вами, будет являться вашим типом.
Пользовательский тип делается вручную и может иметь любой псевдоним.

=== 4.Назовите модификаторы типов

|=====================
|Тип | Длина |Комментарий
|*short int*|	2|Целочисленное знаковое значение укороченной длины
|*unsigned short int*| 2|	Целочисленное беззнаковое значение укороченной длины
|*long int*|	8|Выбор по умолчанию для целочисленных значений. На платформах на которых int равен по
длине unsigned short int может быть длиннее int
|*unsigned long int*|8	|Целое число двойной длины. На платформах на которых int равен по длине unsigned short int может быть
длиннее int
|*long double*|8	|Число с плавающей точкой двойной точности	с двойной точностью 
|=====================

=== 5. Назовите правило установки размеров типов

Размеры типов не четко определены и могут отличаться для различных микроконтроллеров. Для размеров типов существует правило:

----
1             <= sizeof(char)     <= sizeof() <= sizeof(short) <= sizeof(int) <= sizeof(long)
1             <= sizeof(bool)     <= sizeof(long)
sizeof(char)  <= sizeof(long)
sizeof(float) <= sizeof(double)   <= sizeof(long double)
sizeof(T)     == sizeof(signed T) == sizeof(unsigned T)
----
Поэтому вместо прямых типов типа int, используют псевдонимы, например:

std::uint32_t (целое беззнаковое длиной 32 бита)

std::int64_t (целое знаковое длинной 64 бита)

std::uint8_t (целое знаковое длинной 8 бит)

=== 6. Что делает оператор sizeof()?

sizeof() возвращает длину в байтах либо типа данных, либо переменной, которую мы используем с этим ключевым словом. 

=== 7. Что характеризует тип std::size_t?

size_t всегда безнаковый тип. Это специальный тип для указания размера, он уникален тем, что размер этого типа равен максимальному возможному размеру объекта для данной архитектуры. т.е. для 32битной архитектуры - это 2^32 ну или другими словами это псевдоним типа uint32_t. Для 64 машины это уже будет 2^64 или псевдоним типа std::uint64_t

=== 8. Назовите фиксированные типы целых в библиотеке std



[width="100%",options="header,footer"]
|====================
|Название  |Тип  |  Диапазон значений
| int8_t |1 байт signed  |  от -128 до 127
|  uint8_t| 1 байт unsigned |  от 0 до 255
|int16_t  |  2 байта signed| от -32 768 до 32 767 
|uint16_t  |2 байта unsigned  |  от 0 до 65 535
|int32_t  | 4 байта signed |  от -2 147 483 648 до 2 147 483 647
|uint32_t  | 4 байта unsigned | от 0 до 4 294 967 295 
|int64_t  | 8 байт signed |  от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807
| uint64_t | 8 байт unsigned |  от 0 до 18 446 744 073 709 551 615
|====================


=== 9.Что такое псевдоним типа?

Введенное пользователем сочетание сиволов, с которым удобнее работать.

=== 10. Что такое явное и неявное преобразование типа?

Явное - когда преобразование напрямую прописано в коде пользователем. Неявное - когда это делает компилятор сам.

=== 11.Какие явные преобразования типов вы знаете?

Для преобразований из одного типа используют 4 вариантов преобразования:

[source,]
----
static_cast

const_cast

reinterpret_cast

dynamic_cast
----


=== 12 Что делает reinterpret_cast?

Преобразовывает типы, которые несовместны друг с другом 
[source,]
----
пр: Создать указатель типа volatile int*, которая будет содержать адрес регистра GPIOC_MODER

volatile uint32_t *ModerPointer = reinterpret_cast<volatile uint32_t*>(ModerAddr) ;
----

=== 13. Чем static_cast отличается от reinterpret_cast?

static_cast преобразует выражения одного статического типа в объекты и значения другого статического типа. Проверка производится на уровне компиляции, так что в случае ошибки сообщение будет получено в момент сборки приложения или библиотеки. Используется для близких типов.

reinterpret_cast — приведение типов без проверки, непосредственное указание компилятору. Применяется только в случае полной уверенности программиста в собственных действиях. Используется для несовместимых типов.

=== 14. Что такое ОЗУ и ПЗУ? 

ОЗУ - оперативная память, в которую можно записывать программы и считывать их.

ПЗУ(Постоянное запоминающее устройство) - построянная память, в которой можно только читать.



=== 15.Каков размер памяти ARM Cortex микроконтроллеров? 

Ядро ARM имеет 4 Гбайт последовательной памяти с адресов 0x00000000 до 0xFFFFFFFF.

=== 16. По какой архитектуре разработан ARM Cortex микроконтроллер?

Данный микроконтроллер разработан по Гарвардской модифицированной  архитектуре. Память этого микроконтроллера разделена на три отдела:

ПЗУ - память, в которой содержится непосредственно программа.

ОЗУ - память для хранения временных данных, при необходимости и программы, а также регистров, отвечающих за настройку и работу с периферйными устройствами.

Память, в которой хранятся данные EEPROM.


=== 17. В чем отличие Гарвардской архитектуры от Архитектура ФонНеймана?

Устройства с архитектурой Фон Неймана не способны одновременно оперировать с данными (считывать их переписывать) и считывать алгоритм действий, так как для этих действий используется одна шина. Устройства с гарвардской архитектурой могут считывать команды и оперировать данными одновременно, так как потоки команд и данных идут по разным шинам.

=== 18. Где располагаются локальные переменные?

Локальные переменные располагаются в регистрах или стеке.

=== 19.Где располагаются статические переменные?

Статичиские переменные передаются в тот же сегмент памяти, где хранятся глобальные переменные. 
Инициализируемые - .data 
инициализируемые нулем - .bss 
данные переменные не изменяются до конца работы приложения.

=== 20.Где располагаются глобальные переменные?

Глобальные переменные располагаются в фиксированной области памяти, указанной компилятором

=== 21. Что такое стек?

Стек (stack) является структурой данных.Дисциплина работы стека обозначается LIFO, последним пришел — первым ушел (Last In First Out)

image::2.jpeg[]


=== 22.Что такое указатель?

Указатель это переменная, которая хранит расположение (адрес) другой переменной. Тогда можно напрямую писать или читать значение с адреса переменной, либо можно обратиться косвенно, через указатель или ссылку.

=== 23. Что такое разыменовывание указателя?

Как только у нас есть указатель, указывающий на что-либо, мы можем его разыменовать, чтобы получить значение, на которое он указывает. Разыменованный указатель — это содержимое ячейки памяти, на которую он указывает.


=== 24. Что означает взятие адреса?

Оператор & - оператор взятия адреса.
& перед переменной передает адрес по которому лежат значения этой переменной.

=== 25. Какие операции можно выполнять над указателями?

Указатели можно складывать, вычитать, сравнивать. Указатели должны быть одного типа.

=== 26. Что такое константный указатель?

Константный указатель это указатель, значение которого не может быть изменено. Для объявления константного указателя используется ключевое слово const между звёздочкой и именем указателя.

=== 27.Что такое указатель на константу?

Указатель на константное значение — это неконстантный указатель, который указывает на неизменное значение. Для объявления указателя на константное значение, используется ключевое слово const перед типом данных.

=== 28. Что такое ссылка? В чем её отличие от указателя?

Ссылка это псевдоним переменной, который работает как псевдоним другого объекта или значения. У ссылки нельзя взять адрес. Если применить оператор взятия адреса к ней, то будет выведен адрес переменной, на которую она ссылается. Ссылка ведет себя почти также как константный указатель. Её нельзя изменять, складывать, вычитать и сравнивать. Ссылка не может быть не проинициализирована.


=== 29. Что такое регистр?

Регистр - это блок ячеек памяти, образующий сверхбыструю оперативную память внутри процессора. От 8-ми до 32-х бит длиной, который используется для промежуточного хранения информации, обрабатываемой процессором. Некоторые регистры содержат только определенную информацию.

Каждый регистр в архитектуре ARM представляет собой ресурс памяти и имеет длину в 32 бита, где каждый бит можно представить в виде выключателя с помощью которого осуществляется управление тем или иным параметром микроконтроллера.

=== 30. Что такое регистры общего назначения?

Регистры общего назначения - это сверхбыстрая память внутри процессора, предназначенная для хранения адресов и промежуточных результатов вычислений (регистр общего назначения/регистр данных) или данных, необходимых для работы самого процессора.

=== 31.Что такое регистры специального назначения?

Регистры специального назначения расположены в ОЗУ микроконтроллера и используются для управления процессором и периферийными устройствами.

=== 32. Как можно установить бит в регистре специального назначения?

Так как регистр специального назначения - это просто адресуемая ячейка памяти, то в коде это может мы можем обратиться к данным по этому адресу, разыменовывая указатель, указывающий на этот адрес.

Для того, чтобы настроить определенное периферийное устройство процессора, необходимо изменить значение поля соответствующем регистре.

Для более удобной работы с регистрами можно использовать С++ обертку. Эта обертка позволяет обращаться к регистрам в форме очень похоже с тем, как эти регистры описаны в документации.

Так, например, для запуска счетчика, необходимо обратиться к регистру “TIM1” периферии “CR1”, полю CEN и установить в нем значение Enable. Операция обращения к регистру выглядит следующим образом:

 int main()
 {
   TIM1::CR1::CEN::Enable::Set() ;
 }

=== 33. Объясните как вызывается функция.

Функция должна быть объявлена в таком порядке, чтобы компилятор мог узнать как её вызвать. Объявление функции может выглядеть следующим образом:

 int MyFunction(int first, char * second);
 
Все что знает об этой функции компилятор, это то, что она принимает два параметра: целое и указатель на символ. И функция должна вернуть целое значение. Этого достаточно для компилятора, чтобы понять как вызвать эту функцию.

До выполнения функции происходит инициализация стека, инициализация переменных в нулевые значения, инициализация переменнх, запуск функции.

*Вход в функцию*

Параметры передающие в функцию могут использовать два метода:

Через регистры

Через стек

Для большей эффективности параметры передаются через регистры, но их число ограничено, поэтому если регистров не хватает, то используется стек. Для передачи параметров используются оперативные регистры R0:R3

*Выход из функции*

Функция может вернуть значение. Для возврата значения используются регистры R0:R1. Если значение больше 64 бит, то в регистр R0 записывается адрес где лежат данные.

Вызывающая функция обязана очистить стек, после того, как вызываемая функция вернула значение.
 
 
=== 34. Что такое трансляция?

Обработка процессором исходного файла. После трансляции вы можете получить на выходе либо файлы библиотеки, которые впоследствии можно будет использовать в других проектах, либо объектные файлы.

=== 35. Что такое компоновка?

Это объединение нескольких объектных файлов в один исполняемый файл.

=== 36. Как лучше организовывать структуру проекта и почему?

При создании структуры проекта стоит соблюдать иерархическую структуру файлов, хранящихся на компьюетере. Это позволяет облегчить поиск требуемых компонентов. Структура должна иметь иерархическую модель. Все существующие подгруппы разбивают файлы на логические группы.

=== 37. Что такое операторы?

Оператор — это символ, который сообщает компилятору о необходимости выполнения некоторых математических или логических команд.

=== 38. Какие арифметические операторы вы знаете?

|=====================
|**Операция** | *Оператор* | *Комментарий*
|Присваивание       | =     | a = b
|Сложение /вычетание|   + /-  | a +/- b
|Степень          | ^     | a ^ b
|Унарный плюс       | +     | +a
|Унарный минус      | -     | -a
|Умножение          | *     | a * b
|Деление            | /     | a / b
|Остаток от деления | %     | a % b
|Инкремет  (пост и предфиксный)| ++      | &#43;&#43;a  и  a&#43;&#43;
|Декремент (пост и предфиксный)| - -     | --a и a--
|=====================

---


=== 39. Какие логические операторы вы знаете?

|=====================
|*Операция* | *Оператор* | *Комментарий* | *Пример*
|Логическое отрицание, НЕ   | !     | !a    |   !true => false
|Логическое умножение, И    | &&    | a && b| true && false => false
|Логическое сложение, ИЛИ   | &#124;&#124;  |   a &#124; &#124;  b  | true &#124; &#124;  false => true
|=====================


=== 40. Какие побитовые операторы вы знаете?

Побитовые операции — операции, производимые над цепочками битов. Выделяют два типа побитовых операций: логические операции и побитовые сдвиги.

Битовые операторы
[source,]
----
 И (AND, &)

ИЛИ (OR, ∣)

НЕ (NOT, ∼)
----
Побитовое ИЛИ используется для включения битов. Любой бит, установленный в 1, вызывает установку соответствующего бита результата также в 1.

Побитовое И используется для выключения битов. Любой бит, установленный в 0, вызывает установку соответствующего бита результата также в 0

Побитовое НЕ инвертирует состояние каждого бита исходной переменной.

=== 41. Приведите пример переопределения оператора

Синтаксис перегрузки операторов очень похож на определение функции с именем operator@, где @ — это идентификатор оператора (например +, -, <<, >>). 
пример:

[source,]
----
class Integer

{

private://модификатор доступа. доступ открыт самому классу.

int value; // переменная типа int с названием value
public:  //модификатор доступа. доступ открыт классам, производным от данного.

Integer(int i): value(i) 
{}
const Integer operator+(const Integer& rv) const {
return (value + rv.value); //переопределение +
}
};
----

В данном случае, оператор оформлен как член класса, аргумент определяет значение, находящееся в правой части оператора. Вообще, существует два основных способа перегрузки операторов: глобальные функции, дружественные для класса, или подставляемые функции самого класса.

=== 42. Какие еще операторы вы знаете?

* Арифметические операторы;

* Операторы знака;

* Префиксный и постфиксный инкременты;

* Логические операторы;

* Битовый сдвиг;

* Оператор присваивания;

* Операторы сравнения.

=== 43.Как сбросить бит с помощью битовых операторов?

чтобы сбросить бит в переменно нужно применить операцию & и инверсию с числом, в котором этот бит установлен, а все остальные биты равны 0.

[source,]
----
Пример

int Pr10 = 1025 ; //задали переменную равную 1025 в двоичном виде это 10 0000 0001b

Теперь надо сбросить бит номер 10

Pr10 &=~ (1 << 10); → 1025 & 01 1111 1111b → 10 0000 0001b & 01 1111 1111b = 00 0000 0001b
----

==== 44. Как установить бит с помощью битовых операторов?

битовый ИЛИ:

 PORT | = 1; // устанавливает 0-ой бит в PORT
 
 
=== 45. Как поменять значение бита с помощью битовых операторов?

 PORTB ^= 1; // меняет значение в 0-ой бите в PORT

=== 46. Какой микроконтроллер на отладочной плате XNUCLE ST32F411?

STM32F411RE

=== 47. Какие блоки входят в состав микроконтроллера STM32F411?

Блок системы, таймеров, интерфейса, аналоговой периферии, матрица шин, шина периферии

В блок системы входят: внешние, внутренние резонаторы, фапч, схема сброса и тактирования, часы реального времени, системный таймер, сторожевой таймер

image::4.png[]


=== 48. В чем отличие ядра CortexM4 от CortexM3?

Отличия в наборе инструкций: Thumb/Thumb-2​ (М3) Thumb/Thumb-2, DSP, SIMD, FP​ (М4). Также у М3 отстуствует аппаратный модуль работы с плавающей точкой.

=== 49. Назовите основные характеристики микроконтроллера STM32F411.

32 разрядное ядро ARM Cortex-M4

Блок работы с числами с плавающей точкой FPU

512 кБайт памяти программ

128 кБайт ОЗУ

Встроенный 12 битный 16 канальный АЦП

DMA контроллер на 16 каналов

USB 2.0

3x USART

5 x SPI/I2S

3x I2C

SDIO интерфейс для карт SD/MMC/eMMC

Аппаратный подсчет контрольной суммы памяти программ CRC

6 - 16 разрядных и 2 - 32 разрядных Таймера

1 - 16 битный для управления двигателями

2 сторожевых таймера

1 системный таймер

Работа на частотах до 100Мгц

81 портов ввода вывода

Питание от 1.7 до 3.6 Вольт

Потребление 100 мкА/Мгц

=== 50.Назовите дополнительные характеристики микроконтроллера STM32F411.

Настраиваемые источники тактовой частоты

Настраиваемые на различные функции порты

Внутренний температурный сенсор

Таймеры с настраиваемым модулем ШИМ

DMA для работы с модулями (SPI, UART, ADC… )

12 разрядный ADC последовательного приближения

Часы реального времени

Системный таймер и спец. прерывания для облегчения и ускорения работы ОСРВ




=== 51. Какие источники тактирования есть у микроконтроллера STM32F411.

4 основных источника:​

HSI (high-speed internal) — внутренний высокочастотный RC-генератор.​

HSE (high-speed external) — внешний высокочастотный генератор.​

PLL — система ФАПЧ. Точнее сказать, это вовсе и не генератор, а набор из умножителей и делителей, исходный сигнал он получает от HSI или HSE, а на выходе у него уже другая частота.

2 вторичных источника:​

LSI (low-speed internal) — низкочастотный внутренний RC-генератор на 37 кГц​

LSE (low-speed external) — низкочастотный внешний источник на 32,768 кГц​


=== 52. Назовите алгоритм подключения системной частоты к источнику тактирования микроконтроллера STM32F411.

Определить какие источники частоты нужны​(допустим, PLL);

Включить нужный источник? используя Clock Control register (RCC::CR)​

Дождаться стабилизации источника, через соответствующие биты (..RDY) Clock Control register ​(RCC::CR)

Назначить нужный источник на системную частоту​через Clock Configuration Register (RCC::CFGR)​

Дождаться пока источник не переключиться на системную частоту​через Clock Configuration Register (RCC::CFGR)
​

=== 53. Что такое ФАПЧ?

Фазовая автоподстройка частоты (ФАПЧ, англ. PLL ) — система автоматического регулирования, подстраивающая фазу управляемого генератора так, чтобы она была равна фазе опорного сигнала, либо отличалась на известную функцию от времени.



=== 54. Что делает следующий код?

[source,]
----
int main()
{
  int StudentUdacha = 10;
  int PrepodUdachca = 0 ;

  StudentUdacha =  StudentUdacha ^ PrepodUdachca ;
  PrepodUdachca =  StudentUdacha ^ PrepodUdachca ;
  StudentUdacha ^= PrepodUdachca ;
}
----

 int StudentUdacha = 10; // Присваивает переменной StudentUdacha значение 10

 int PrepodUdachca = 0 ; // Присваивает переменной PrepodUdachca значение 0


 StudentUdacha =  StudentUdacha ^ PrepodUdachca ; //поразрядное исключающее ИЛИ



  StudentUdacha ^= PrepodUdachca ;// инвевртирует значение
}

*Произойдет обмен значений между пееременными StudentUdacha и PrepodUdachca StudentUdacha=0 PrepodUdachca=10*





















